name: Release Builds

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (must already exist)"
        required: true

permissions:
  contents: write

defaults:
  run:
    shell: bash

env:
  RELEASE_TAG: ${{ github.event_name == 'release' && github.event.release.tag_name || github.event_name == 'workflow_dispatch' && github.event.inputs.tag || github.ref_name }}
  RELEASE_REF: ${{ github.event_name == 'workflow_dispatch' && format('refs/tags/{0}', github.event.inputs.tag) || github.ref }}

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            python_version: "3.11"
            suffix: linux
            ffmpeg_platform: linux
            build_sdist: true
          - os: macos-latest
            python_version: "3.11"
            suffix: macos
            ffmpeg_platform: darwin
            build_sdist: false
          - os: windows-latest
            python_version: "3.11"
            suffix: windows
            ffmpeg_platform: win
            build_sdist: false

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_REF }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python_version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install build pyinstaller yt-dlp ytmusicapi
          python -m pip install -e .

      - name: Ensure license directory
        run: mkdir -p licenses

      - name: Fetch FFmpeg (Linux)
        if: ${{ matrix.ffmpeg_platform == 'linux' }}
        run: |
          mkdir -p resources/ffmpeg/linux
          curl -L -o ffmpeg.tar.xz https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz
          tar -xf ffmpeg.tar.xz
          cp ffmpeg-*-amd64-static/ffmpeg resources/ffmpeg/linux/ffmpeg
          chmod +x resources/ffmpeg/linux/ffmpeg

      - name: Fetch FFmpeg (macOS)
        if: ${{ matrix.ffmpeg_platform == 'darwin' }}
        run: |
          mkdir -p resources/ffmpeg/darwin
          curl -L -o ffmpeg.zip https://evermeet.cx/ffmpeg/ffmpeg-6.1.1.zip
          unzip -o ffmpeg.zip ffmpeg -d resources/ffmpeg/darwin
          chmod +x resources/ffmpeg/darwin/ffmpeg

      - name: Fetch FFmpeg (Windows)
        if: ${{ matrix.ffmpeg_platform == 'win' }}
        shell: pwsh
        run: |
          $destDir = "resources/ffmpeg/windows"
          $destExe = Join-Path $destDir "ffmpeg.exe"
          if (Test-Path $destExe) {
            Write-Host "Using existing FFmpeg at $destExe"
            return
          }
          Write-Host "Downloading FFmpeg for Windows…"
          New-Item -ItemType Directory -Force -Path $destDir | Out-Null
          $primary = "https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-win64-gpl.zip"
          $fallback = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
          $tmpZip = Join-Path $env:TEMP ("ffmpeg_" + [Guid]::NewGuid().ToString() + ".zip")
          $tmpDir = Join-Path $env:TEMP ("ffmpeg_unpack_" + [Guid]::NewGuid().ToString())
          try {
            try {
              Invoke-WebRequest -Uri $primary -OutFile $tmpZip -UseBasicParsing
            } catch {
              Write-Host "Primary FFmpeg download failed, trying fallback…"
              Invoke-WebRequest -Uri $fallback -OutFile $tmpZip -UseBasicParsing
            }
            Expand-Archive -Path $tmpZip -DestinationPath $tmpDir -Force
            $ffmpeg = Get-ChildItem -Path $tmpDir -Recurse -Filter "ffmpeg.exe" | Select-Object -First 1
            if (-not $ffmpeg) {
              throw "ffmpeg.exe not found in downloaded archive"
            }
            Copy-Item $ffmpeg.FullName $destExe -Force
          } finally {
            Remove-Item $tmpZip -Force -ErrorAction SilentlyContinue
            Remove-Item $tmpDir -Recurse -Force -ErrorAction SilentlyContinue
          }

      - name: Build source and wheel distributions
        if: ${{ matrix.build_sdist == true }}
        run: python -m build

      - name: Confirm PyInstaller spec file
        run: |
          if [ ! -f "CSVMusic.spec" ]; then
            echo "Unable to locate CSVMusic.spec" >&2
            echo "Repository contents:" >&2
            ls -al >&2
            exit 1
          fi

      - name: Build PyInstaller bundle
        run: pyinstaller CSVMusic.spec

      - name: Package PyInstaller bundle
        env:
          PACKAGE_SUFFIX: ${{ matrix.suffix }}
        run: |
          python - <<'PY'
          from __future__ import annotations
          import os
          import pathlib
          import zipfile
          import shutil
          import sys
          import stat

          suffix = os.environ["PACKAGE_SUFFIX"]
          dist_dir = pathlib.Path("dist")
          app_dir = dist_dir / "CSVMusic"
          # Handle cases:
          # - One-folder: dist/CSVMusic is a directory (use as-is)
          # - One-file (Linux/mac): dist/CSVMusic is a file (create a staging dir)
          # - One-file (Windows): dist/CSVMusic.exe exists (create dir and copy)
          staging_root: pathlib.Path | None = None
          if app_dir.exists() and app_dir.is_file():
              # Create a staging folder to wrap the single-file binary
              staging_root = dist_dir / "_pkgroot"
              if staging_root.exists():
                  shutil.rmtree(staging_root)
              (staging_root / "CSVMusic").mkdir(parents=True, exist_ok=True)
              shutil.copy2(app_dir, (staging_root / "CSVMusic" / app_dir.name))
              app_dir = staging_root / "CSVMusic"
          elif not app_dir.exists():
              single_candidates = [
                  dist_dir / "CSVMusic.exe",
                  dist_dir / "CSVMusic",
              ]
              # macOS app bundle
              mac_app = dist_dir / "CSVMusic.app"
              if mac_app.exists() and mac_app.is_dir():
                  app_dir = mac_app
              else:
                  for candidate in single_candidates:
                      if candidate.exists():
                          app_dir.mkdir(exist_ok=True)
                          shutil.copy2(candidate, app_dir / candidate.name)
                          break
                  else:
                      raise SystemExit(
                          "Missing PyInstaller output: neither directory nor single-file bundle found"
                      )
          # Ensure yt-dlp CLI is bundled alongside the app binary so runtime
          # resolution in csvmusic.core.paths.ytdlp_path() can find it.
          def _ensure_exec(p: pathlib.Path) -> None:
              try:
                  mode = p.stat().st_mode
                  p.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
              except Exception:
                  pass

          plat_win = sys.platform.startswith("win")
          ytdlp_name = "yt-dlp.exe" if plat_win else "yt-dlp"
          # Determine where the app's executable lives so yt-dlp sits alongside it
          bin_dir = app_dir
          if app_dir.suffix == ".app":
              cand = app_dir / "Contents" / "MacOS"
              if cand.exists():
                  bin_dir = cand
          elif (app_dir / "CSVMusic").exists() or (app_dir / "CSVMusic.exe").exists():
              bin_dir = app_dir
          # Always fetch official standalone yt-dlp for portability
          dst_ytdlp = bin_dir / ytdlp_name
          url = (
              "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp.exe" if plat_win else
              ("https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp_macos" if sys.platform.startswith("darwin") else
               "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp_linux")
          )
          try:
              import urllib.request
              with urllib.request.urlopen(url) as r, open(dst_ytdlp, "wb") as f:
                  shutil.copyfileobj(r, f)
          except Exception as e:
              raise SystemExit(f"Failed to download yt-dlp from {url}: {e}")
          _ensure_exec(dst_ytdlp)
          zip_path = dist_dir / f"CSVMusic-{suffix}.zip"
          with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
              zf.write(app_dir, app_dir.name + "/")
              for path in sorted(app_dir.rglob("*")):
                  if path.is_dir():
                      continue
                  arcname = app_dir.name + "/" + path.relative_to(app_dir).as_posix()
                  zf.write(path, arcname)
          # Cleanup staging if used (zip is already written)
          if staging_root and staging_root.exists():
              shutil.rmtree(staging_root, ignore_errors=True)
          PY

      - name: Collect PyInstaller bundle
        run: |
          mkdir -p release
          cp dist/CSVMusic-${{ matrix.suffix }}.zip release/

      - name: Collect Python distributions
        if: ${{ matrix.build_sdist == true }}
        run: |
          mkdir -p release
          cp dist/*.whl release/
          cp dist/*.tar.gz release/

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.suffix }}
          path: release

  publish:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: Upload release assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          files: |
            release/*.whl
            release/*.tar.gz
            release/*.zip
